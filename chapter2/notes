## ELF binary - four parts
1. Executable header
2. program header
3. sections
4. section headers

## file path for elf header
/usr/include/ elf.h

## e_ident array
16 bytes

0x7f, E, L, F --> magic bytes
4 --> EI_CLASS --> set to ELFCLASS32 = 1 early for 32 bit now set to ELFCLASS64 = 2 for 64 bit
5 --> EI_DATA --> set to ELFDATA2LSB(1) = little endian and if set to ELFDATA2MSB(2)  = big endian
6 --> version of ELF, set to EV_CURRENT = 1
7 --> EI_OSABI =>  information regarding Application Binary Interface(ABI) and OS 
                   if non-zero, some OS-specific/ABI specific extensions used in ELF,
                   change in meanining of fields, some nonstd. headers,
                   if 0  -> UNIX V abi
8 --> EI_ABIVERSION => ABI version
9---15 --> EL_PAD

## examining the binary header
readelf -h a.out

## e_type, e_machine, e_version
1. e_type:
    type of ELF binary
    common val: ET_REL(relocatable object file), ET_EXEC(an executable binary), ET_DYN(shared object file)
2. e_machine
    type of arch. binary intended to run on
    common val: EM_X86_64, EM_386(32 bit bin), EM_ARM(ARM bin)
3. e_version
  same as EI_VERSION in ei_ident array.. set to EV_CURRENT

## e_entry-> entry point of bin, interpreter will transfer control over here

## e_phoff, e_shoff fields
e_phoff -> offset to program headers table
e_shoff -> offset to section headers table
if 0, means no header

## e_flags
flags specific to arch.
generally set to 0 for intel x86_64

## e_ehsize: ELF header size = 64 bytes for 64 bit while = 52byte for 32 bit

## e_*entsize and e_*num :

Linker and loader need size of program/section headers + number of such headers
e_phentsize and e_phnum -> size and number of headers for program headers table
e_shentsize and e_shnum -> size and number of headers for section headers table

## e_shstrdx 
Index in section header table for .shstrtab (strings table)

Examining the .shstrtab using readelf
readelf -x .shstrtab build/a.out

## section headers

section - link time
segments - run time
optional in ELF
location: /usr/include/elf.h

1. sh_name : index into .shstrtab defines name of section, if 0 then no name

## sh_type:
Each section's type. 
Info to linker about structure of sections content
SHT_PROGBITS -> machine instructions and constants. Nothing for linker to parse. 
SHT_SYMTAB -> static symbol table
SHT_DYNSYM -> dynamic symbol table
SHT_STRTAB -> string tables
SHT_REL / SHT_RELA -> useful for linker(static linking)
SHT_DYNAMIC -> useful for linker(dynamic linking)

Content: struct name
Symbol : Elf64_Sym
linker info: Elf64_Rel and Elf64_Rela
linker info(Dynamic): Elf64_Dyn

## sh_flags field
sections flags
most imp flags : SH_WRITE, SH_ALLOC, SH_EXECINSTR
SHF_WRITE: section is wriable(variables)
SHF_ALLOC : section content to be loaded in Virt Mem. while run time
SHF_EXEC : section is executable

## sh_addr, sh_offset, sh_size
1. sh_addr : virtual address of section
2. sh_offset: offset to section from start of file
3. sh_size : size of the section

##  sh_link:
relationship among sections. index(in the SH table) of related section

## sh_info: 
additional info for section. Example for relocation section it is index of section for which reloactions needs to be applied

## sh_addralign
if this section need addr alignment..

## sh_entsize
Some header entries present in section header table, print size of those entries

## Sections

##To view the sections in ELF

readelf --sections --wide build/a.out

First section in ELF
SHT_NULL -> section header with no section present

## .init and .fini section
.init -> executable section, executes program before main function starts
.fini -> executable section, executes program after main function finished

## .text section

most of code/ Area of focus for binary analysis and rev engg
Executable but not writable
Contains some of the functions that perform initialization and finalization
_start, register_tm_clones and frame_dummy

main focus: _start --> _libc_start_main --> main

e_entry of ELF HEADER = virtual address for _start

## .bss, .data and .rodata section

.text is not writable, so variables are stored in other sections to keep binary neat
.data ->  default value of initialized vars.. writable
.rodata -> constants and not writable
.bss -> 'block started by symbol' contains uninitialized data

.data and .rodata -> marked as SHT_PROGBITS
.bss -> marked as SHT_NOBITS "doesn't  occupy any bits in binary as it exists on disk". This is just a directive to say allocate this much block of memory for uninitialized data durting ELF execution. vars initialized to zero, writable

## Lazy binding and .plt, .got, .plt.got section

dynamic linker -> last minute relocations
resolution is done only when first reference to unresolved symbol is made.. lazy binding

## Lazy binding and .plt section

LD_BIND_NOW


